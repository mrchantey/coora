use convert_case::{Case, Casing};
use proc_macro2::Span;
use syn::{
	parse::Result, spanned::Spanned, Error, FnArg, ItemTrait, LitStr, Pat, ReturnType, TraitItem,
	Type,
};

pub fn rust_pat_to_str(pat: &Pat) -> Result<String> {
	if let Pat::Ident(pat) = pat {
		Ok(pat.ident.to_string())
	} else {
		Err(Error::new(pat.span(), "Expected identifier"))
	}
}

pub fn rust_type_to_ts(rtype: &Type) -> Result<String> {
	if let Type::Path(rt) = rtype {
		Ok(rt.path.segments.first().unwrap().ident.to_string())
	} else {
		Err(Error::new(
			rtype.span(),
			"Currently only primitives are allowd",
		))
	}
}

pub fn rust_method_to_ts(plugin_name: &str, item: &TraitItem) -> Result<String> {
	if let TraitItem::Method(item) = item {
		let return_type = if let ReturnType::Type(_rarrow, rtype) = &item.sig.output {
			rust_type_to_ts(&**rtype)
		} else {
			Ok(format!("void"))
		}?;


		#[rustfmt::skip]
		let args:std::result::Result<Vec<_>, _> = item.sig.inputs.iter().map(|item| {
			if let FnArg::Typed(item) = item {
				let ty = rust_type_to_ts(&*item.ty)?;
				let ident = rust_pat_to_str(&*item.pat)?;
				return Ok(format!("{}: {}",ident,ty))
			} else {
				Err(Error::new(item.span(), "'self' is not a valid argument"))
			}
		})
		.filter(|a|a.is_ok())//ignore invalid
		.collect();
		let args = args?.join(", ");

		Ok(format!(
			"
//@ts-ignore external
@external(\'{}\', \'{}\')
export declare function {}({}): {};",
			plugin_name,
			item.sig.ident,
			item.sig.ident.to_string().to_case(Case::Camel),
			args,
			return_type
		))
	} else {
		Err(Error::new(
			item.span(),
			"Currently only functions can be used as plugin imports, are you accidentally using 'pub'?",
		))
	}
}


const PREFIX: &str = r"//AUTOGENERATED";
const SUFFIX: &str = r"";

pub fn generate_typescript_bindings(plugin: &ItemTrait) -> Result<LitStr> {
	let mut out = String::from(PREFIX);
	let body = plugin.items.iter();
	for item in body {
		let ts_func = rust_method_to_ts(plugin.ident.to_string().as_str(), item)?;
		out.push_str(ts_func.as_str());
	}


	out.push_str(SUFFIX);
	let out = LitStr::new(out.as_str(), Span::call_site());
	Ok(out)
}
